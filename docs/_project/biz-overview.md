# 业务概览（biz-overview）

> 文档路径：`/docs/_project/biz-overview.md`
>
> * 文档状态：草稿
> * 创建人：yinwm
> * 创建日期：2026-01-14
> * 更新日期：2026-01-14

---

## 1. 背景与现状（Background）

### 现状
用户正在开发 **VibedevTeam** 工作流框架,用于多 AI Dev 并行开发。当前工作流分为两个阶段:

1. **规划阶段**: 确定 Epic → 写文档(PRD/TECH/STORY/SLICE/TASK) → 用 beads 编排任务
2. **开发阶段**: 用 proj 人格进行进度跟踪 → 识别可并行任务 → 启动多个 dev 并行开发 → tech review → proj 汇总进度并继续分派任务

目前已实现:
- ✅ Beads 任务管理系统(Git-backed issue tracker)
- ✅ 多 Agent 协作框架(biz-owner/prd/tech/proj/dev 等)
- ✅ 标准化文档模板和工作流
- ✅ TDD 驱动的开发流程

### 痛点
在实际使用多 AI Dev 并行开发时,遇到以下核心问题:

1. **认知过载**
   - 需要在多个终端间切换上下文
   - 4 个并行 dev 已经"跟不住了"
   - 每个终端都是独立的对话上下文,无法统一管理

2. **进度可视化缺失**
   - 需要人工盯着终端看进度
   - 任务状态散落在各处
   - 经常忘了"这个 Task 是为了哪个 PRD 服务的"
   - 依赖关系不清晰,不知道哪些任务可以并行

3. **调度效率低**
   - 手动识别可并行任务
   - 手动在终端间切换,给不同的 dev 分派任务
   - 无法实时看到所有 Agent 的工作状态

4. **知识断层**
   - Epic → PRD/TECH → SLICE → TASK 的依赖关系不可见
   - 讨论、拆解、开发的知识是分散的
   - 缺乏全局视角

### 为什么现在要做
1. **紧迫性**: 用户已经在实践中遇到瓶颈,4 个并行 dev 已经是极限,但理论上应该能管理更多
2. **技术可行性**: Claude Code 提供 stream-json I/O 模式,可以外部管理对话
3. **战略价值**: 这是 VibedevTeam 的核心基础设施,直接影响开发效率
4. **参考项目已有先例**: Gas Town(Multi-agent orchestration for Claude Code)、Vibe-Kanban(Kanban board for AI agents)

---

## 2. 业务问题（Problems）

### P1: 多 Agent 并行调度的认知负荷过高
**现状描述**:
- 用户需要在多个终端窗口间切换,每个终端对应一个 Claude Code 实例
- 需要记住哪个 dev 在做什么任务,当前进度如何
- 手动判断任务依赖关系,决定分派顺序
- 4 个并行 dev 已经达到认知极限

**根因分析**:
- 缺乏统一的状态可视化管理
- 缺乏任务依赖关系的自动识别
- 缺乏 Agent 生命周期的自动化管理

**影响**:
- 限制了并行度,无法充分利用 AI 的并行能力
- 容易出错,可能遗漏某个 dev 的进度
- 时间浪费在上下文切换上

### P2: 知识依赖关系不可追溯
**现状描述**:
- 文档(Epic/PRD/TECH/SLICE/TASK)之间的关系是隐式的
- 讨论过程中的决策和背景知识散落在对话历史中
- 无法快速回答"这个 Task 是为了解决什么业务问题"

**根因分析**:
- 缺乏知识图谱的可视化
- 文档之间的依赖关系没有显式建模
- 讨论内容和任务执行结果没有关联

**影响**:
- 新人(或未来的自己)难以理解全局
- 容易失去对"为什么做这件事"的感知
- 复盘和总结困难

### P3: Agent 生命周期管理复杂
**现状描述**:
- Claude Code 进程需要手动启动/杀死
- Session 恢复需要手动操作
- 资源管理(闲置 Agent 的释放)需要人工判断

**根因分析**:
- 缺乏进程管理的抽象层
- 缺乏 Session 状态的持久化和恢复机制
- 缺乏资源使用的监控和自动化

**影响**:
- 操作繁琐,容易出错
- 资源浪费(闲置 Agent 占用内存)
- 体验不够流畅

---

## 3. 业务目标与指标（Goals & Metrics）

| 目标ID | 目标（Goal） | 当前值 | 目标值 | 口径/备注 |
|------|------------|------|------|--------|
| G1 | 能同时管理的并行 Dev 数量 | 4 个 | 8+ 个 | 在不增加认知负荷的前提下 |
| G2 | 单次上下文切换时间 | [OPEN] | < 5 秒 | 从一个 Agent 的状态切换到另一个 Agent 的状态 |
| G3 | 任务依赖关系可见性 | 0% | 100% | 所有 TASK 都能追溯到对应的 PRD/TECH |
| G4 | Agent 闲置资源释放时间 | 人工 | 5 分钟 | 自动检测并释放闲置超过 5 分钟的 Agent |
| G5 | 全局状态刷新时间 | [OPEN] | < 1 秒 | 知识图谱树、Agent 状态等全局视图的刷新延迟 |

### 反证信号（什么情况说明假设错了）
- 如果做了控制台后,用户仍然需要在终端间切换 → 说明调度能力不足
- 如果知识图谱树太复杂,反而增加了认知负荷 → 说明可视化方式有问题
- 如果进程管理频繁出错(Claude Code 进程杀不死/启动不了) → 说明底层通信不稳定

### 止损信号（什么情况要停下来）
- **技术止损**: 如果无法稳定实现 Claude Code 的 stream-json 通信,退回到"一次性任务"模式
- **功能止损**: 如果进程管理太复杂,简化为"手动启动",先聚焦可视化和调度
- **范围止损**: 如果 Tauri 开发成本太高,考虑降级到 Web 应用(失去系统级能力)

---

## 4. 范围与非目标（Scope & Non-goals）

### 本期范围（Phase 1 - MVP）

**核心价值**: 让用户能舒适地管理 8+ 个并行 Dev,而不增加认知负荷

#### In Scope
1. **知识图谱树**
   - 解析文档 Frontmatter,显示 Epic → PRD/TECH → SLICE → TASK 的依赖关系
   - 实时更新(监听文件系统变化)
   - 点击节点打开对应文档
   - 显示任务状态(TODO/DOING/BLOCKED/DONE)

2. **讨论室**
   - 多 tab 支持,保持不同 Agent 的对话上下文
   - 和具名 Agent(Tiger、Dave-1/2、Terry 等)进行多轮对话
   - Agent 可以创建文档、编码(通过 Claude Code 的工具)
   - 对话历史持久化(JSONL 格式)

3. **运行终端**
   - 显示各个 Agent 的执行进度
   - 实时日志流(stream-json 输出)
   - 进程状态指示(运行中/空闲/错误)

4. **进程管理**
   - 启动/杀死 Claude Code 进程
   - Session 管理(从 JSONL 恢复上下文)
   - 资源监控(内存、CPU、闲置时间)

5. **员工档案**
   - 显示每个"数字员工"的状态
   - 当前任务、技能标签
   - 历史任务记录(可选)

6. **手动调度**（L1 级别）
   - 手动分派任务给 Agent
   - 手动触发 Agent 启动/停止

### 非目标（Phase 2+）

#### Out Scope（延后到后续版本）
1. **自动任务调度**（L2 级别）
   - 自动匹配"TASK-01 需要后端" → 找 Dave-1
   - 自动检测任务依赖,识别可并行任务
   - 依赖冲突检测和解决

2. **智能摘要**
   - 压缩对话历史,减少上下文长度
   - 自动生成日报/周报

3. **自主协调**（L3 级别）
   - Agent 之间自主协商任务分配
   - Agent 自主拆解任务

4. **非技术用户支持**
   - 傻瓜化操作界面
   - 无需了解 Claude Code 即可使用

5. **多模态交互**
   - 语音输入/输出
   - 可视化拖拽式任务编排

6. **团队协作**
   - 多用户共享控制台
   - 权限管理
   - 审计日志

---

## 5. Epic 列表（Epics）

| Epic ID | 名称 | 价值 | 本期范围 | 优先级 | 状态 | 备注 |
|--------|------|------|--------|------|------|------|
| E-001 | AI 员工管理控制台 - Commander Console | 解决多 Agent 并行调度的认知负荷问题 | MVP: 知识图谱 + 讨论室 + 终端 + 进程管理 | P0 | 草稿 | 第一个 Epic,验证技术可行性和价值 |

---

## 6. Roadmap（可选）

### 版本节奏

#### MVP（Phase 1）
**目标**: 伺候好用户自己,解决 4 并行 dev 的调度问题

**核心能力**:
- 知识图谱树(依赖关系可视化)
- 讨论室(多 Agent 对话)
- 运行终端(日志流 + 进程状态)
- 进程管理(启动/杀死/恢复)
- 员工档案(Agent 状态)
- 手动调度(L1 级别)

**成功标准**:
- ✅ 能同时管理 4 个并行 dev 而不抓狂
- ✅ 一眼看到所有任务的状态和依赖关系
- ✅ 不需要在多个终端间切换
- ✅ 进程闲置 5 分钟后自动释放资源

#### V1.1（Phase 2）
**目标**: 扩展到 8+ 并行 dev,提升自动化水平

**新增能力**:
- 自动任务调度(L2 级别)
- 依赖冲突检测
- 智能分派建议

#### V2.0（Phase 3）
**目标**: 支持其他小队(设计、测试、运营)

**新增能力**:
- 小队模板(开发小队/设计小队/测试小队)
- 自主协调(L3 级别)
- 跨小队协作

#### V3.0（Phase 4）
**目标**: 非技术用户可用

**新增能力**:
- 傻瓜化操作界面
- 无需了解 Claude Code
- 一键部署

### 资源与约束
**技术栈**:
- 框架: Tauri v2(Rust + Webview)
- 前端: [OPEN]（候选: React/Vue/Svelte）
- 后端: Rust
- 通信: Claude Code stream-json I/O
- 存储: JSONL + Frontmatter

**约束**:
- 需要系统级能力(启动/杀死进程)
- 未来要给非技术用户用(单一可执行文件)
- 需要支持跨平台(至少 macOS + Linux)

**风险**:
- Claude Code 的 stream-json 模式可能不稳定
- Tauri 开发成本可能比预期高
- Session 恢复可能有问题

---

## 7. 商业模式与目标用户（Business Model & Target Users）

### 目标用户演化

| 阶段 | 目标用户 | 核心需求 | 付费意愿 |
|-----|---------|---------|---------|
| **Phase 1** | 开发者（用户自己） | 解决多 Agent 并行调度的认知负荷问题 | 不适用(自用) |
| **Phase 2** | 其他独立开发者/小团队 | 可视化状态、简化操作、提升并行度 | [OPEN] |
| **Phase 3** | 非技术用户 | 傻瓜化操作,无需了解技术细节 | [OPEN] |

### 当前聚焦
**Phase 1 - 伺候好用户自己**

**核心假设**:
- 如果能解决用户自己的问题,其他开发者也会有类似需求
- VibedevTeam 的核心价值在于"多 AI Dev 并行开发",控制台是关键基础设施
- 未来可以作为独立产品开源或商业化

### 产品定位
**产品名称**: Commander Console（指挥官控制台）

**核心定位**: AI 员工管理系统(AI Workforce Management System)

**长期愿景**:
- 构建面向未来的 AI 员工管理平台
- 第一个落地场景: 开发小队
- 未来扩展: 设计小队、测试小队、运营小队...

### 参考项目
- **Gas Town**: Multi-agent orchestration for Claude Code (https://github.com/steveyegge/gastown)
- **Vibe-Kanban**: Kanban board for AI agents (https://github.com/BloopAI/vibe-kanban)

---

## 8. Southwest 飞轮（综合价格 / TCO）

**我们要降低的"综合价格"**:
1. **时间成本**: 从"手动在终端间切换" → "统一控制台"
2. **认知负荷**: 从"记住 4 个 dev 的状态" → "一眼看全"
3. **学习成本**: 从"需要熟悉 Claude Code 命令" → "可视化操作"

**降低综合价格后,受众会扩大还是频次会提高**:
- **并行度提升**: 从 4 个并行 dev → 8+ 个并行 dev,开发效率翻倍
- **使用门槛降低**: 未来可以让非技术用户也能用 AI 员工
- **频次提升**: 更愿意使用多 Agent 协作,而不是单 Agent 串行

**规模起来以后,哪些成本会被摊薄**:
- ✅ 软件边际成本: 一次开发,无限复用
- ✅ 自动化: 进程管理、调度逻辑都是自动的
- ✅ 标准化: Agent 模板、工作流模板可复用

**哪些成本不会摊薄**:
- ❌ 每个 Agent 的 Token 成本(仍然需要付费给 Claude)
- ❌ 复杂任务的执行时间(AI 生成代码的速度不变)

**飞轮断裂风险**:
- 如果可视化太复杂,反而增加认知负荷 → 需要简洁的 UI 设计
- 如果进程管理不稳定,频繁出错 → 需要优雅的降级方案
- 如果只支持开发者,非技术用户用不了 → 这是 Phase 3 的事

**最早可验证的信号**:
- **信号1**: 能不能稳定地管理 4 个并行 dev?(验证周期: 2 周)
- **信号2**: 知识图谱树是否真的帮助理解全局?(验证周期: 1 周)
- **信号3**: 进程管理是否稳定?(验证周期: 持续验证)

**止损条件**:
- 如果 2 周内无法稳定管理 4 个并行 dev → 说明技术方案有问题,需要调整
- 如果知识图谱树反而增加了认知负荷 → 说明可视化方式有问题,需要简化
- 如果进程管理频繁出错 → 退回到"手动启动",先聚焦可视化和调度

---

## 9. 调度能力分级（Orchestration Levels）

| 级别 | 能力 | 描述 | 当前目标 |
|-----|------|------|---------|
| **L1** | 手动调度 | "Dave-1 领 TASK-01" | ✅ Phase 1 |
| **L2** | 自动匹配 | "TASK-01 需要后端" → 找 Dave-1 | Phase 2 |
| **L3** | 自主协调 | "做登录功能" → 拆任务、分派 | Phase 3 |
| **L4** | 自主决策 | "提升留存" → 分析、方案、执行 | 长期愿景 |

**当前聚焦**: L1 手动调度
- 用户手动分派任务给 Agent
- 控制台提供可视化支持
- 降低认知负荷,但不替代决策

---

## 10. 核心功能（Key Features）

### 1. 知识图谱树
**价值**: 一眼看全局,理解任务依赖关系

**核心能力**:
- 显示文档依赖关系: EPIC → PRD/TECH → SLICE → TASK
- 实时更新(监听文件系统变化)
- 点击节点打开对应文档
- 显示任务状态(TODO/DOING/BLOCKED/DONE)
- 高亮显示当前关注的任务路径

**技术方案**:
- 解析 Frontmatter 中的元数据
- 文件系统监听(inotify/FSEvents)
- 图形库(候选: D3.js/Cytoscape.js/vis.js)

### 2. 讨论室
**价值**: 集中管理多 Agent 对话,不需要在终端间切换

**核心能力**:
- 多 tab 支持,保持不同 Agent 的对话上下文
- 和具名 Agent(Tiger、Dave-1/2、Terry 等)进行多轮对话
- Agent 可以创建文档、编码(通过 Claude Code 的工具)
- 对话历史持久化(JSONL 格式)
- 搜索历史对话

**技术方案**:
- Tab 组件(类似浏览器)
- Claude Code stream-json I/O
- JSONL 存储

### 3. 运行终端
**价值**: 实时看到所有 Agent 的执行进度,不需要盯着多个终端

**核心能力**:
- 显示各个 Agent 的执行进度
- 实时日志流(stream-json 输出)
- 进程状态指示(运行中/空闲/错误)
- 日志搜索和过滤
- 高亮错误/警告

**技术方案**:
- 终端模拟器(候选: xterm.js)
- 实时日志流(stream-json 解析)
- WebSocket 推送(如果需要多窗口同步)

### 4. 进程管理
**价值**: 自动化管理 Agent 生命周期,释放闲置资源

**核心能力**:
- 启动/杀死 Claude Code 进程
- Session 管理(从 JSONL 恢复上下文)
- 资源监控(内存、CPU、闲置时间)
- 自动释放闲置超过 5 分钟的 Agent

**技术方案**:
- Rust 启动子进程(std::process::Command)
- 进程状态监控
- JSONL Session 恢复

### 5. 员工档案
**价值**: 理解每个"数字员工"的状态和能力

**核心能力**:
- 显示每个 Agent 的状态(空闲/忙碌/错误)
- 当前任务
- 技能标签(架构/后端/前端/测试...)
- 历史任务记录(可选)
- 性能统计(可选)

**技术方案**:
- Agent 元数据存储(Frontmatter/JSON)
- 状态实时更新
- 统计分析(可选)

---

## 11. 风险与 OPEN

### 技术风险

1. **Claude Code 的 stream-json 模式可能不稳定**
   - **风险等级**: 高
   - **影响**: 无法实现多轮对话,需要退回到"一次性任务"模式
   - **缓解方案**:
     - 先做技术验证(PoC),确认 stream-json 的稳定性
     - 如果不稳定,考虑降级到"一次性任务"模式
     - 记录所有边界情况和错误处理

2. **Session 恢复可能有问题**
   - **风险等级**: 中
   - **影响**: 无法恢复对话历史,用户体验差
   - **缓解方案**:
     - 设计健壮的 Session 格式(JSONL)
     - 添加版本号和迁移逻辑
     - 提供手动修复工具

3. **Tauri 开发成本可能比预期高**
   - **风险等级**: 中
   - **影响**: 开发周期延长
   - **缓解方案**:
     - 先做最小可行原型(MVP)
     - 如果 Rust 后端太复杂,考虑降级到 Web 应用
     - 复用现有组件和库

### 业务风险

1. **可视化可能反而增加认知负荷**
   - **风险等级**: 中
   - **影响**: 用户不愿意使用
   - **缓解方案**:
     - 简洁的 UI 设计,避免信息过载
     - 提供折叠/过滤功能
     - 用户测试和反馈迭代

2. **Agent 命名和角色定义可能不清晰**
   - **风险等级**: 低
   - **影响**: 用户不知道该找哪个 Agent
   - **缓解方案**:
     - 提供默认的 Agent 模板
     - 允许用户自定义 Agent 角色
     - 提供技能标签和描述

### [OPEN] 待确认问题

1. **前端框架选择**
   - [ ] React / Vue / Svelte?
   - 考虑因素: 学习曲线、生态、性能、开发体验
   - 建议: 先做技术调研,快速验证

2. **知识图谱可视化库选择**
   - [ ] D3.js / Cytoscape.js / vis.js?
   - 考虑因素: 功能、性能、学习曲线
   - 建议: 先做原型,对比效果

3. **终端模拟器选择**
   - [ ] xterm.js / 其他?
   - 考虑因素: 功能、性能、兼容性
   - 建议: 先验证 xterm.js 是否满足需求

4. **Session 格式设计**
   - [ ] JSONL 结构如何定义?
   - 需要支持: 对话历史、任务状态、错误恢复
   - 建议: 参考现有格式(如 ChatGPT 的导出格式)

5. **Agent 模板设计**
   - [ ] 默认提供哪些 Agent?
   - Tiger(架构师)、Dave-1/2(开发)、Terry(Reviewer)...
   - 建议: 先基于现有的 Agent 定义

6. **跨平台支持**
   - [ ] 是否需要支持 Windows?
   - 考虑因素: 用户群体、开发成本
   - 建议: 先支持 macOS + Linux,Windows 后续

7. **多窗口支持**
   - [ ] 是否需要支持多窗口?
   - 考虑因素: 用户场景、开发复杂度
   - 建议: 先单窗口,多窗口后续

---

## 12. 变更记录（Changelog）

| 版本 | 日期 | 修改人 | 修改内容 |
|------|------|--------|----------|
| v1.0 | 2026-01-14 | yinwm | 初版 |
